H. SharedPtr
============

Ограничение времени

1 секунда

Ограничение памяти

64Mb

Ввод

стандартный ввод или input.txt

Вывод

стандартный вывод или output.txt

Напишите свою упрощённую реализацию класса std::shared\_ptr<T>.

Подробную спецификацию стандартного std::shared\_ptr можно посмотреть на [http://en.cppreference.com/w/cpp/memory/shared\_ptr](http://en.cppreference.com/w/cpp/memory/shared_ptr). В этой задаче вам не нужно делать специализацию для массива и не нужно предусматривать свой Deleter.

Назовите ваш класс SharedPtr. У класса должен быть один шаблонный параметр T – тип элемента, указатель на который будет храниться внутри.

Напишите следующие функции в классе:

1.  Конструктор по умолчанию, создающий пустой умный указатель.
2.  Конструктор, принимающий T \* и захватывающий владение этой динамической памятью.
3.  Конструктор копирования, принимающий на вход другой аналогичный SharedPtr и увеличивающий счётчик ссылок на данный объект.
4.  Конструктор перемещения, получающий на вход rvalue-ссылку на другой SharedPtr и отбирающий у него владение ресурсом.
5.  Оператор присваивания, получающий на вход указатель. В результате счётчик ссылок на текущий объект должен уменьшиться, а SharedPtr должен захватить владение переданным указателем.
6.  Оператор присваивания, получающий на вход другой SharedPtr. В результате счётчик ссылок на текущий объект должен уменьшиться, а SharedPtr должен присоединиться к владению переданным указателем.
7.  Move-оператор присваивания, получающий на вход rvalue-ссылку на другой SharedPtr. Этот оператор должен немедленно уничтожать ссылку на старый объект (аналогично стандартному std::shared\_ptr)
8.  Деструктор.
9.  Константный и неконстантный оператор \*.
10.  Оператор ->.
11.  Функцию void reset(T \* ptr), после выполнения которой умный указатель должен уменьшить счётчик ссылок и захватить ptr.
12.  Функцию void swap(SharedPtr& other), обменивающуюся содержимым с другим умным указателем.
13.  Функцию T \* get() const, возвращающую указатель.
14.  explicit operator bool() const, позволяющий определить, не пуст ли умный указатель.

Пометьте все подходящие функции тегом noexcept (чтобы подчеркнуть, что они не должны генерировать исключений).

В вашей программе не должно быть утечек памяти. Объект, которым владеет SharedPtr, должен быть удален тогда и только тогда, когда будет уничтожен последний SharedPtr, владеющий им.

Примечания
----------

Сдайте только код самого класса без функции main. Использовать стандартный std::shared\_ptr запрещается.

Мы будем тестировать ваш класс с помощью вот такого кода: [https://clck.ru/FN2WS](https://clck.ru/FN2WS).