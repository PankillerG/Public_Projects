E. Vector-2
===========

Ограничение времени

1 секунда

Ограничение памяти

64Mb

Ввод

стандартный ввод или input.txt

Вывод

стандартный вывод или output.txt

Реализуйте свой класс Vector<T>, аналогичный std::vector<T>. В отличие от задачи Vector-1 класс должен быть шаблонным и должен работать с любым типом T, имеющим конструктор по умолчанию, конструктор копирования и деструктор. Дополните набор функций предыдущей задачи функциями capacity, reserve, resize, clear, swap, begin, end. В качестве итераторов вектора можно использовать обычные указатели. Обратите внимание, что вектор должен резервировать «сырую» память, и конструировать элементы в ней только при необходимости. Ваш класс должен непосредственно работать с динамической памятью: пользоваться аналогичными классами стандартной библиотеки запрещено.

Примечания
----------

Обратите внимание на следующие особенности:

1.  Конструктор без параметров не должен резервировать память для вектора.
2.  Конструктор с одним параметром (размером вектора) должен резервировать память ровно указанного объёма.
3.  Конструктор копирования должен резервировать ровно столько памяти, сколько требуется для хранения элементов.
4.  При возникновении исключений в функциях шаблонного типа T не должно происходить утечек памяти.
5.  При реаллокации в функции push\_back пустой вектор должен приобрести ёмкость 1, а вектор ненулевой ёмкости должен удвоить свою ёмкость.
6.  Если ёмкости вектора в функции resize не хватает, то при реаллокации вектор должен приобрести минимально возможную необходимую ёмкость.
7.  Функция reserve и оператор присваивания должны давать строгие гарантии безопасности: если при реаллокации произошел сбой, то вектор не должен изменить своего состояния.
8.  Функции resize и push\_back должны давать базовую гарантию безопасности: если при добавлении элемента произошел сбой, то состояние вектора может измениться, но оно должно быть согласованным.
9.  Функция push\_back должна иметь перегруженную версию, принимающую на вход rvalue-ссылку T&&.
10.  Вызовы деструкторов для элементов должны происходить в прямом порядке (начиная с первого элемента).
11.  Мы компилируем вашу программу с опцией -fsanitize=address, чтобы обнаружить возможные утечки памяти. Кроме того, мы при тестировании используем ваш вектор с элементами нашего класса C, который печатает в своих конструкторах, операторах присваивания и деструкторах сообщения о вызове. Поведение вашего класса должно быть таким же, как и стандартного вектора.

Вот наш код, с помощью которого мы будем тестировать ваш класс: [https://clck.ru/FKoBk](https://clck.ru/FKoBk).

Реализации стандартного вектора могут отличаться, поэтому выкладываем пример ожидаемого результата работы теста: [https://clck.ru/FP5DL](https://clck.ru/FP5DL).