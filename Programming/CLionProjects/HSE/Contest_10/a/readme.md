A. UniquePtr-1
==============

Ограничение времени

1 секунда

Ограничение памяти

64Mb

Ввод

стандартный ввод или input.txt

Вывод

стандартный вывод или output.txt

Напишите свою упрощённую реализацию класса std::unique\_ptr<T>.

Подробную спецификацию стандартного std::unique\_ptr можно посмотреть на [http://en.cppreference.com/w/cpp/memory/unique\_ptr](http://en.cppreference.com/w/cpp/memory/unique_ptr). В этой задаче вам не нужно делать специализацию для массива и не нужно предусматривать свой Deleter.

Назовите ваш класс UniquePtr. У класса должен быть один шаблонный параметр T - тип элемента, указатель на который будет храниться внутри.

Напишите следующие функции в классе:

1.  Конструктор по умолчанию, создающий пустой умный указатель.
2.  Конструктор, принимающий T \* и захватывающий владение этой динамической памятью.
3.  Конструктор перемещения, получающий на вход rvalue-ссылку на другой UniquePtr и отбирающий у него владение ресурсом.
4.  Оператор присваивания, получающий на вход nullptr (тип - std::nullptr\_t, определенный в заголовочном файле cstddef). В результате умный указатель должен стать пустым.
5.  Move-оператор присваивания, получающий на вход rvalue-ссылку на другой UniquePtr.
6.  Деструктор.
7.  Константный оператор \*.
8.  Константный оператор -> (он должен вернуть просто сам указатель).
9.  Функцию T \* release(), отменяющую владение объектом и возвращающую хранящийся внутри указатель.
10.  Функцию void reset(T \* ptr), после выполнения которой умный указатель должен захватить ptr.
11.  Функцию void swap(UniquePtr& other), обменивающуюся содержимым с другим умным указателем.
12.  Функцию T \* get() const, возвращающую указатель.
13.  explicit operator bool() const, позволяющий определить, не пуст ли умный указатель.

В вашем классе должны быть запрещены конструктор копирования и обычный оператор присваивания. Пометьте все подходящие функции тегом noexcept (чтобы подчеркнуть, что они не должны генерировать исключений).

sizeof вашего класса должен совпадать с sizeof от обычного указателя, а дополнительной динамической памяти внутри UniquePtr выделяться не должно. То есть UniquePtr не должен иметь накладных расходов на память по сравнению с обычным указателем.

Примечания
----------

Сдайте только код самого класса без функции main. Использовать стандартный std::unique\_ptr запрещается.