D. Недетерминированный конечный автомат
=======================================

Все языки

Python 3.2

Ограничение времени

6 секунд

60 секунд

Ограничение памяти

16Mb

256Mb

Ввод

стандартный ввод или input.txt

Вывод

стандартный вывод или output.txt

Вам предстоит реализовать недетерминированный конечный автомат по описанию его переходов и протестировать его работу. Для простоты алфавит автомата ограничен строчными буквами латинского алфавита (a-z).

Формат ввода
------------

Первая строка содержит число N (1 <= N <= 3000) - число состояний автомата. Следующие N строк содержат описания очередного состояния:  
0 или 1 - является ли состояние допускающим (1, если допускает),  
E (0 <= E <= 2000) - число эпсилон-переходов из данного состояния,  
далее E номеров состояний, в которые возможен эпсилон-переход из данного состояния,  
T (0 <= T <= 26) - число переходов из данного состояния,  
далее T пар описаний переходов: символ и номер состояния. Общее количество переходов не превосходит 5000.

Следующая за описанием автомата строка содержит число M (1 <= M <= 2000) - число строк, на которых полученный автомат следует протестировать. Следующие M строк содержат тестовые входы и состоят строго из строчных букв латинского алфавита (a-z). Суммарная длина всех слов не превосходит 15000.

Состояния автомата нумеруются с нуля, нулевое состояние автомата является его начальным состоянием.

Формат вывода
-------------

Выход должен содержать M + 1 строк с числами 0 или 1:  
в первой строке выхода следует следует вывести 1, если автомат допускает пустую строку, либо 0, если не допускает;  
в следующих M строках следует вывести 1, если автомат допускает очередную строку из тестового входа, либо 0, если не допускает.

Пример
------

##### Ввод

```
3
1 1 2 1 a 1
0 0 1 b 2
0 1 0 0
5
a
b
ab
aba
abab```

##### Вывод

```
1
0
0
1
0
1
```

Примечания
----------

Примечание 1.

Часто вместо "автомат допускает X" и "допускающее состояние" говорят "автомат принимает X" и "принимающее состояние".

Примечание 2.

Запрограммировать недетерминированный конечный автомат можно несколькими способами. Например, можно привести его к детерминированному автомату. Так работают генераторы автоматов вроде ragel. Недостаток - экспоненциальный рост числа состояний в худшем случае.

Над недетерминированным автоматом можно организовать поиск с возвратом (backtracking). Так работает большинство библиотек регулярных выражений. Недостаток - экспоненциальное по размеру входа время работы в худшем случае.

Также над недетерминированным автоматом можно реализовать алгоритм Томпсона, который гарантирует линейное по размеру входа время работы и линейную по числу состояний память. Так работает библиотека re2 и утилита grep. Алгоритм состоит в построении эпсилон-замыкания текущего набора состояний и нахождении всех состояний, в которые можно перейти из этого замыкания по очередному символу.  
  
Thompson(NFA, input)  
    current\_states = NFA->EpsilonClosure(NFA->Start)  
    for (char in input)  
        next\_states = \[ \]  
        for (state in current\_states)  
            if (next = NFA->NextState(state, char))  
                next\_states += next  
        current\_states = NFA->EpsilonClosure(next\_states)  
    for (state in current\_states)  
        if (NFA->Accepts(state))  
            return 1  
    return 0